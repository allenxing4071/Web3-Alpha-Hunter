# 项目发现与评分体系

## 📋 文档概述

**文档目标**: 设计从话题热度和评论区发现早期项目的完整方法论  
**核心理念**: 数据驱动 + 交叉验证 + AI评分  
**更新时间**: 2025-10-04

---

## 🎯 核心目标

**我们要发现什么样的项目？**

1. **未发币但有潜力** - Pre-Token项目
2. **话题热度上升** - 社区讨论增加
3. **多平台验证** - 不是单一来源的炒作
4. **团队背景优质** - 有成功经验或顶级VC背书
5. **技术有创新** - 不是简单Copy

**目标ROI**: 在项目发币后实现 10-100倍收益

---

## 🔍 项目发现流程

### 整体流程图

```
┌────────────────────────────────────────────────────────────────┐
│  第一步: 多平台数据采集                                         │
│  Twitter + Telegram + Discord + Medium + GitHub                │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│  第二步: 项目名称提取与聚合                                     │
│  NLP识别 + 正则匹配 + 实体识别                                 │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│  第三步: 初步筛选（去除噪音）                                   │
│  已发币过滤 + 诈骗项目过滤 + 低质量过滤                        │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│  第四步: 交叉验证（多源确认）                                   │
│  至少2个平台提及 + 官方渠道验证 + 团队真实性验证               │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│  第五步: 深度数据收集                                           │
│  社交媒体数据 + GitHub数据 + 融资信息 + 链上数据               │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│  第六步: AI综合评分                                             │
│  6维度评分模型 + 发币概率预测 + 空投价值估算                   │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│  第七步: 分级与推送                                             │
│  S级(立即推送) A级(每日报告) B级(观察) C级(忽略)                │
└────────────────────────────────────────────────────────────────┘
```

---

## 📊 第一步: 从话题热度发现项目

### 1.1 热度指标定义

**什么是"热度"？**

热度 = 提及频次 × 增长速度 × KOL参与度 × 情感倾向

```python
def calculate_topic_heat(project_name: str, time_window: int = 24) -> float:
    """计算项目话题热度"""
    
    # 1. 提及频次（40%权重）
    mentions = count_mentions(project_name, hours=time_window)
    mention_score = min(40, mentions / 10)  # 每10次提及得1分，最高40分
    
    # 2. 增长速度（30%权重）
    previous_mentions = count_mentions(project_name, hours=time_window*2, offset=time_window)
    growth_rate = (mentions - previous_mentions) / previous_mentions if previous_mentions > 0 else 0
    growth_score = min(30, growth_rate * 100)  # 增长率100%=30分
    
    # 3. KOL参与度（20%权重）
    kol_mentions = count_kol_mentions(project_name, hours=time_window)
    kol_score = min(20, kol_mentions * 4)  # 每个KOL提及得4分
    
    # 4. 情感倾向（10%权重）
    sentiment = analyze_sentiment(project_name)
    sentiment_score = sentiment * 10  # -1到1映射到-10到10
    
    total_heat = mention_score + growth_score + kol_score + sentiment_score
    
    return max(0, min(100, total_heat))
```

### 1.2 突然爆发检测

**目标**: 发现突然开始被讨论的项目

```python
def detect_sudden_surge(project_name: str) -> dict:
    """检测突然爆发的项目"""
    
    # 获取过去7天的每小时提及数
    hourly_mentions = []
    for hour in range(7 * 24):
        count = count_mentions(project_name, hours=1, offset=hour)
        hourly_mentions.append(count)
    
    # 计算基线（前6天的平均值）
    baseline = sum(hourly_mentions[:144]) / 144
    
    # 计算最近24小时的平均值
    recent_avg = sum(hourly_mentions[-24:]) / 24
    
    # 判断是否突然爆发
    surge_ratio = recent_avg / baseline if baseline > 0 else 0
    
    is_surge = surge_ratio > 3  # 增长超过3倍视为爆发
    
    return {
        "project": project_name,
        "baseline_mentions_per_hour": baseline,
        "recent_mentions_per_hour": recent_avg,
        "surge_ratio": surge_ratio,
        "is_sudden_surge": is_surge,
        "surge_start_time": find_surge_start(hourly_mentions) if is_surge else None
    }


def find_surge_start(hourly_data: List[int]) -> datetime:
    """找到爆发起始时间"""
    
    baseline = sum(hourly_data[:144]) / 144
    
    # 从后往前找，找到第一个超过基线2倍的点
    for i in range(len(hourly_data) - 1, 143, -1):
        if hourly_data[i] > baseline * 2:
            continue
        else:
            # 找到爆发起始点
            return datetime.now() - timedelta(hours=len(hourly_data) - i - 1)
    
    return datetime.now()
```

### 1.3 评论区挖掘算法

**目标**: 从高互动帖子的评论区发现早期项目

```python
def mine_comments_for_projects(post_id: str, platform: str) -> List[dict]:
    """从评论区挖掘项目"""
    
    # 1. 获取所有评论
    comments = get_all_comments(post_id, platform)
    
    # 2. 质量过滤（参考05文档中的质量评分）
    quality_comments = [c for c in comments if c["quality_score"] > 60]
    
    # 3. 提取项目提及
    project_mentions = []
    
    for comment in quality_comments:
        # 使用NLP提取项目名称
        projects = extract_project_names(comment["text"])
        
        for project in projects:
            # 检查是否已知项目
            is_known = check_if_known_project(project)
            
            if not is_known:
                # 新发现的项目
                project_mentions.append({
                    "project_name": project,
                    "mentioned_in_comment": comment["id"],
                    "comment_author": comment["author"],
                    "comment_likes": comment["likes"],
                    "context": extract_context(comment["text"], project),
                    "sentiment": analyze_sentiment_towards(comment["text"], project),
                    "platform": platform,
                    "discovered_at": datetime.now()
                })
    
    # 4. 聚合相同项目的提及
    aggregated = aggregate_mentions(project_mentions)
    
    return aggregated


def extract_project_names(text: str) -> List[str]:
    """从文本中提取项目名称"""
    
    projects = []
    
    # 方法1: 正则匹配（大写开头的词组）
    # 例如: "Uniswap", "Ethereum Name Service"
    pattern1 = r'\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\b'
    matches1 = re.findall(pattern1, text)
    projects.extend(matches1)
    
    # 方法2: 识别特定模式
    # 例如: "Check out XXX Protocol"
    pattern2 = r'check out\s+([A-Z][a-zA-Z\s]+?)(?:\.|,|$)'
    matches2 = re.findall(pattern2, text, re.IGNORECASE)
    projects.extend(matches2)
    
    # 方法3: 识别网站链接
    # 例如: "uniswap.org" -> "Uniswap"
    urls = re.findall(r'https?://([a-zA-Z0-9-]+)\.[a-z]+', text)
    for url in urls:
        project_name = url.replace('-', ' ').title()
        projects.append(project_name)
    
    # 方法4: NER命名实体识别（使用AI）
    ner_projects = ai_extract_project_names(text)
    projects.extend(ner_projects)
    
    # 去重和清洗
    projects = list(set([p.strip() for p in projects]))
    
    # 过滤噪音（通用词汇）
    noise_words = ["Bitcoin", "Ethereum", "Solana"]  # 已知大项目
    projects = [p for p in projects if p not in noise_words]
    
    return projects


def ai_extract_project_names(text: str) -> List[str]:
    """使用AI提取项目名称"""
    
    prompt = f"""
    从以下文本中提取所有提及的Web3项目名称。
    只返回项目名称，每行一个。
    如果没有提及任何项目，返回空。
    
    文本：
    {text}
    
    项目名称：
    """
    
    response = call_ai_api(prompt, model="gpt-4")
    
    # 解析响应
    projects = [line.strip() for line in response.split('\n') if line.strip()]
    
    return projects
```

### 1.4 多维度信号聚合

**目标**: 从多个维度综合判断项目热度

```python
class ProjectSignal(BaseModel):
    """项目信号"""
    
    project_name: str
    
    # 提及数据
    twitter_mentions: int
    telegram_mentions: int
    discord_mentions: int
    medium_mentions: int
    reddit_mentions: int
    
    # 增长数据
    mention_growth_24h: float  # 24小时增长率
    mention_growth_7d: float   # 7天增长率
    
    # KOL数据
    kol_tier1_mentions: int
    kol_tier2_mentions: int
    kol_tier3_mentions: int
    
    # 评论区数据
    comment_discovery_count: int  # 评论区发现次数
    avg_comment_quality: float    # 平均评论质量
    
    # 情感数据
    positive_ratio: float  # 正面情感比例
    neutral_ratio: float
    negative_ratio: float
    
    # 综合指标
    overall_heat: float  # 0-100
    signal_strength: int  # 0-100
    confidence: float  # 0-1


def aggregate_project_signals(project_name: str) -> ProjectSignal:
    """聚合项目信号"""
    
    # 1. 统计各平台提及
    twitter_count = count_mentions(project_name, platform="twitter", hours=24)
    telegram_count = count_mentions(project_name, platform="telegram", hours=24)
    discord_count = count_mentions(project_name, platform="discord", hours=24)
    medium_count = count_mentions(project_name, platform="medium", days=7)
    reddit_count = count_mentions(project_name, platform="reddit", hours=24)
    
    # 2. 计算增长率
    growth_24h = calculate_growth_rate(project_name, hours=24)
    growth_7d = calculate_growth_rate(project_name, days=7)
    
    # 3. 统计KOL提及
    kol_mentions = count_kol_mentions_by_tier(project_name)
    
    # 4. 评论区数据
    comment_data = get_comment_discoveries(project_name)
    
    # 5. 情感分析
    sentiment = aggregate_sentiment(project_name)
    
    # 6. 计算综合热度
    heat = calculate_topic_heat(project_name)
    
    # 7. 计算信号强度
    signal = calculate_signal_strength(
        mentions=twitter_count + telegram_count + discord_count,
        growth=growth_24h,
        kol_count=sum(kol_mentions.values()),
        sentiment=sentiment["positive_ratio"]
    )
    
    # 8. 计算置信度（基于数据来源的多样性）
    sources = sum([
        twitter_count > 0,
        telegram_count > 0,
        discord_count > 0,
        medium_count > 0,
        reddit_count > 0
    ])
    confidence = min(1.0, sources / 3)  # 至少3个平台才高置信
    
    return ProjectSignal(
        project_name=project_name,
        twitter_mentions=twitter_count,
        telegram_mentions=telegram_count,
        discord_mentions=discord_count,
        medium_mentions=medium_count,
        reddit_mentions=reddit_count,
        mention_growth_24h=growth_24h,
        mention_growth_7d=growth_7d,
        kol_tier1_mentions=kol_mentions["tier1"],
        kol_tier2_mentions=kol_mentions["tier2"],
        kol_tier3_mentions=kol_mentions["tier3"],
        comment_discovery_count=comment_data["count"],
        avg_comment_quality=comment_data["avg_quality"],
        positive_ratio=sentiment["positive_ratio"],
        neutral_ratio=sentiment["neutral_ratio"],
        negative_ratio=sentiment["negative_ratio"],
        overall_heat=heat,
        signal_strength=signal,
        confidence=confidence
    )
```

---

## ✅ 第二步: 交叉验证机制

### 2.1 多源验证

**目标**: 确保项目不是单一来源的虚假炒作

```python
def cross_validate_project(project_name: str) -> dict:
    """交叉验证项目"""
    
    validation_result = {
        "project_name": project_name,
        "is_valid": False,
        "confidence": 0.0,
        "validation_details": {}
    }
    
    # 验证1: 官方网站存在且有效
    website = find_official_website(project_name)
    if website:
        domain_age = get_domain_age(website)
        ssl_valid = check_ssl(website)
        
        validation_result["validation_details"]["website"] = {
            "exists": True,
            "url": website,
            "domain_age_days": domain_age,
            "ssl_valid": ssl_valid,
            "score": min(20, domain_age / 10) if domain_age > 30 else 0
        }
    
    # 验证2: 社交媒体账号真实性
    social_accounts = find_social_accounts(project_name)
    
    twitter_valid = False
    if social_accounts.get("twitter"):
        twitter = get_twitter_account(social_accounts["twitter"])
        twitter_valid = (
            twitter["followers"] > 100 and
            twitter["tweets"] > 10 and
            twitter["age_days"] > 30
        )
        validation_result["validation_details"]["twitter"] = {
            "exists": True,
            "followers": twitter["followers"],
            "tweets": twitter["tweets"],
            "age_days": twitter["age_days"],
            "score": 20 if twitter_valid else 5
        }
    
    # 验证3: GitHub仓库活跃
    github = find_github_repo(project_name)
    if github:
        is_active = (
            github["commits_30d"] > 10 and
            github["contributors"] > 2
        )
        validation_result["validation_details"]["github"] = {
            "exists": True,
            "url": github["url"],
            "stars": github["stars"],
            "commits_30d": github["commits_30d"],
            "contributors": github["contributors"],
            "score": 25 if is_active else 10
        }
    
    # 验证4: 融资信息
    funding = check_funding_info(project_name)
    if funding:
        is_credible = verify_funding_sources(funding)
        validation_result["validation_details"]["funding"] = {
            "exists": True,
            "amount": funding["amount"],
            "investors": funding["investors"],
            "verified": is_credible,
            "score": 20 if is_credible else 5
        }
    
    # 验证5: 媒体报道
    media_mentions = count_media_mentions(project_name)
    validation_result["validation_details"]["media"] = {
        "mention_count": media_mentions,
        "score": min(15, media_mentions * 3)
    }
    
    # 计算总分
    total_score = sum([
        detail.get("score", 0)
        for detail in validation_result["validation_details"].values()
    ])
    
    # 判断是否有效
    validation_result["is_valid"] = total_score >= 60
    validation_result["confidence"] = min(1.0, total_score / 100)
    
    return validation_result
```

### 2.2 诈骗项目识别

**目标**: 过滤掉骗局项目

```python
def detect_scam_signals(project_name: str) -> dict:
    """检测诈骗信号"""
    
    scam_score = 0  # 分数越高越可疑
    red_flags = []
    
    # 红旗1: 团队匿名
    team_info = get_team_info(project_name)
    if not team_info or len(team_info) == 0:
        scam_score += 20
        red_flags.append("团队信息缺失或完全匿名")
    
    # 红旗2: 不合理的承诺
    marketing_text = get_all_marketing_text(project_name)
    suspicious_keywords = [
        "guaranteed returns", "100x guaranteed", "get rich quick",
        "risk-free", "cannot lose", "guaranteed profit"
    ]
    
    for keyword in suspicious_keywords:
        if keyword in marketing_text.lower():
            scam_score += 15
            red_flags.append(f"包含可疑承诺: '{keyword}'")
    
    # 红旗3: 抄袭白皮书
    whitepaper = get_whitepaper(project_name)
    if whitepaper:
        similarity = check_whitepaper_plagiarism(whitepaper)
        if similarity > 0.8:  # 80%以上相似
            scam_score += 25
            red_flags.append(f"白皮书疑似抄袭（相似度{similarity*100:.0f}%）")
    
    # 红旗4: 合约未审计
    contract = get_contract_address(project_name)
    if contract:
        audit_reports = check_audit_reports(contract)
        if not audit_reports:
            scam_score += 15
            red_flags.append("智能合约未经审计")
    
    # 红旗5: 社交媒体刷量
    twitter = get_twitter_account(project_name)
    if twitter:
        bot_ratio = detect_bot_followers(twitter["username"])
        if bot_ratio > 0.5:  # 超过50%机器人
            scam_score += 20
            red_flags.append(f"Twitter粉丝疑似刷量（机器人比例{bot_ratio*100:.0f}%）")
    
    # 红旗6: 域名/账号年龄过短
    website = find_official_website(project_name)
    if website:
        domain_age = get_domain_age(website)
        if domain_age < 7:  # 不到1周
            scam_score += 15
            red_flags.append(f"域名注册时间过短（{domain_age}天）")
    
    # 红旗7: 流动性过低
    if contract:
        liquidity = get_liquidity(contract)
        if liquidity and liquidity < 10000:  # 少于$10k
            scam_score += 10
            red_flags.append(f"流动性过低（${liquidity}）")
    
    return {
        "project_name": project_name,
        "scam_score": scam_score,
        "is_likely_scam": scam_score >= 50,
        "risk_level": "High" if scam_score >= 50 else "Medium" if scam_score >= 30 else "Low",
        "red_flags": red_flags
    }
```

### 2.3 已发币项目过滤

**目标**: 排除已经发币的项目

```python
def check_token_status(project_name: str) -> dict:
    """检查项目是否已发币"""
    
    # 方法1: CoinGecko/CoinMarketCap查询
    coingecko_result = search_coingecko(project_name)
    if coingecko_result:
        return {
            "has_token": True,
            "token_symbol": coingecko_result["symbol"],
            "token_address": coingecko_result["contract"],
            "market_cap": coingecko_result["market_cap"],
            "source": "CoinGecko"
        }
    
    # 方法2: DEX查询（Uniswap, PancakeSwap等）
    dex_result = search_dex_pairs(project_name)
    if dex_result:
        return {
            "has_token": True,
            "token_address": dex_result["token_address"],
            "dex": dex_result["dex_name"],
            "liquidity": dex_result["liquidity"],
            "source": "DEX"
        }
    
    # 方法3: 官方声明检查
    official_announcement = search_token_announcement(project_name)
    if official_announcement:
        return {
            "has_token": True,
            "announcement_date": official_announcement["date"],
            "source": "Official"
        }
    
    # 方法4: 区块浏览器搜索
    # ...
    
    return {
        "has_token": False,
        "checked_at": datetime.now()
    }
```

---

## 🤖 第三步: AI综合评分系统

### 3.1 六维度评分模型

```python
class ProjectScore(BaseModel):
    """项目综合评分"""
    
    # 六大维度
    team_score: int  # 团队背景（0-100）
    tech_score: int  # 技术创新（0-100）
    community_score: int  # 社区热度（0-100）
    tokenomics_score: int  # 代币经济（0-100）
    market_score: int  # 市场时机（0-100）
    risk_score: int  # 风险评估（0-100，分数越高风险越低）
    
    # 综合得分
    composite_score: int  # 加权综合分（0-100）
    
    # 分级
    grade: str  # S/A/B/C
    
    # 推荐度
    recommendation: str  # Strong Buy, Buy, Hold, Pass


def calculate_comprehensive_score(project_name: str) -> ProjectScore:
    """计算综合评分"""
    
    # 1. 团队背景评分（权重20%）
    team_score = assess_team_background(project_name)
    
    # 2. 技术创新评分（权重25%）
    tech_score = assess_technical_innovation(project_name)
    
    # 3. 社区热度评分（权重20%）
    community_score = assess_community_heat(project_name)
    
    # 4. 代币经济评分（权重15%）
    tokenomics_score = assess_tokenomics(project_name)
    
    # 5. 市场时机评分（权重10%）
    market_score = assess_market_timing(project_name)
    
    # 6. 风险评估评分（权重10%）
    risk_score = assess_risks(project_name)
    
    # 计算加权综合分
    composite = (
        team_score * 0.20 +
        tech_score * 0.25 +
        community_score * 0.20 +
        tokenomics_score * 0.15 +
        market_score * 0.10 +
        risk_score * 0.10
    )
    
    # 致命风险降级
    scam_check = detect_scam_signals(project_name)
    if scam_check["is_likely_scam"]:
        composite *= 0.5  # 降50%
    
    # 顶级VC加分
    if has_top_tier_vc(project_name):
        composite += 5
    
    composite = max(0, min(100, composite))
    
    # 确定分级
    if composite >= 85:
        grade = "S"
        recommendation = "Strong Buy"
    elif composite >= 70:
        grade = "A"
        recommendation = "Buy"
    elif composite >= 55:
        grade = "B"
        recommendation = "Hold"
    else:
        grade = "C"
        recommendation = "Pass"
    
    return ProjectScore(
        team_score=int(team_score),
        tech_score=int(tech_score),
        community_score=int(community_score),
        tokenomics_score=int(tokenomics_score),
        market_score=int(market_score),
        risk_score=int(risk_score),
        composite_score=int(composite),
        grade=grade,
        recommendation=recommendation
    )
```

### 3.2 团队背景评分

```python
def assess_team_background(project_name: str) -> float:
    """评估团队背景（0-100分）"""
    
    score = 0
    team_info = get_team_info(project_name)
    
    if not team_info:
        return 0  # 团队信息缺失
    
    # 因子1: 团队成员数量（15分）
    team_size = len(team_info)
    score += min(15, team_size * 3)  # 5人团队满分
    
    # 因子2: 成员背景（40分）
    for member in team_info:
        # FAANG背景
        if member.get("previous_companies"):
            faang = ["Google", "Facebook", "Amazon", "Apple", "Microsoft"]
            if any(company in member["previous_companies"] for company in faang):
                score += 8
        
        # Web3成功项目经验
        if member.get("previous_web3_projects"):
            successful = [p for p in member["previous_web3_projects"] if p["success"]]
            score += len(successful) * 5
        
        # 学历
        if member.get("education"):
            top_schools = ["MIT", "Stanford", "CMU", "Berkeley", "ETH Zurich"]
            if any(school in member["education"] for school in top_schools):
                score += 3
    
    score = min(score, 40)  # 这部分最高40分
    
    # 因子3: 团队完整性（20分）
    roles = [m.get("role") for m in team_info]
    required_roles = ["CEO", "CTO", "CMO"]  # 核心角色
    completeness = sum([1 for role in required_roles if role in roles]) / len(required_roles)
    score += completeness * 20
    
    # 因子4: 社交媒体活跃度（15分）
    for member in team_info:
        if member.get("twitter"):
            twitter = get_twitter_account(member["twitter"])
            if twitter["followers"] > 10000:
                score += 5
    
    score = min(score, 15)
    
    # 因子5: 团队透明度（10分）
    # 公开LinkedIn、照片、详细简历
    transparency = sum([
        member.get("linkedin") is not None,
        member.get("photo") is not None,
        member.get("bio") is not None
    ]) / (len(team_info) * 3)
    
    score += transparency * 10
    
    return min(100, score)
```

### 3.3 技术创新评分

```python
def assess_technical_innovation(project_name: str) -> float:
    """评估技术创新（0-100分）"""
    
    score = 0
    
    # 因子1: GitHub活跃度（30分）
    github = find_github_repo(project_name)
    if github:
        # 代码提交频率
        commits_30d = github["commits_30d"]
        score += min(10, commits_30d / 10)
        
        # 贡献者数量
        contributors = github["contributors"]
        score += min(10, contributors * 2)
        
        # 代码质量
        code_quality = analyze_code_quality(github["url"])
        score += code_quality * 10  # 0-1映射到0-10
    
    # 因子2: 技术文档质量（20分）
    docs = get_technical_docs(project_name)
    if docs:
        doc_score = assess_docs_quality(docs)
        score += doc_score * 20
    
    # 因子3: 技术创新性（30分）
    whitepaper = get_whitepaper(project_name)
    if whitepaper:
        innovation = ai_assess_innovation(whitepaper)
        score += innovation * 30
    
    # 因子4: 安全审计（20分）
    contract = get_contract_address(project_name)
    if contract:
        audits = check_audit_reports(contract)
        if audits:
            # 有审计报告
            score += 10
            
            # 顶级审计公司加分
            top_auditors = ["Certik", "Trail of Bits", "OpenZeppelin"]
            if any(auditor in audits for auditor in top_auditors):
                score += 10
    
    return min(100, score)


def ai_assess_innovation(whitepaper_text: str) -> float:
    """AI评估技术创新性（0-1）"""
    
    prompt = f"""
    请评估以下Web3项目白皮书的技术创新性。
    评分标准：
    - 0.9-1.0: 革命性创新，全新技术范式
    - 0.7-0.9: 重大创新，显著技术突破
    - 0.5-0.7: 渐进式创新，有技术改进
    - 0.3-0.5: 小幅创新，主要是工程优化
    - 0.0-0.3: 无明显创新，抄袭或简单复制
    
    只返回0-1之间的数字。
    
    白皮书内容：
    {whitepaper_text[:5000]}
    
    创新性评分：
    """
    
    response = call_ai_api(prompt, model="gpt-4")
    
    try:
        score = float(response.strip())
        return max(0, min(1, score))
    except:
        return 0.5  # 默认中等
```

### 3.4 社区热度评分

```python
def assess_community_heat(project_name: str) -> float:
    """评估社区热度（0-100分）"""
    
    score = 0
    
    # 因子1: Twitter粉丝与互动（30分）
    twitter = get_twitter_account(project_name)
    if twitter:
        # 粉丝数
        followers = twitter["followers"]
        score += min(15, followers / 10000 * 15)  # 10万粉丝满分
        
        # 互动率
        engagement_rate = twitter["avg_engagement"] / twitter["followers"]
        score += min(15, engagement_rate * 100 * 15)  # 互动率10%满分
    
    # 因子2: Telegram成员与活跃度（25分）
    telegram = get_telegram_info(project_name)
    if telegram:
        # 成员数
        members = telegram["member_count"]
        score += min(15, members / 5000 * 15)  # 5万成员满分
        
        # 活跃度
        daily_messages = telegram["daily_messages"]
        score += min(10, daily_messages / 1000 * 10)  # 1000条/天满分
    
    # 因子3: Discord活跃度（25分）
    discord = get_discord_info(project_name)
    if discord:
        activity_score = discord["activity_score"]
        score += activity_score * 0.25
    
    # 因子4: 增长趋势（20分）
    growth = calculate_community_growth(project_name, days=30)
    
    # Twitter增长
    twitter_growth = growth["twitter_followers_growth"]
    score += min(10, twitter_growth * 100)  # 10%增长满分
    
    # Telegram增长
    telegram_growth = growth["telegram_members_growth"]
    score += min(10, telegram_growth * 100)
    
    return min(100, score)
```

### 3.5 发币概率预测

```python
def predict_token_launch_probability(project_name: str) -> dict:
    """预测项目发币概率"""
    
    probability = 0
    signals = []
    estimated_timeline = None
    
    # 强信号（每个+15%概率）
    
    # 1. 官方宣布快照时间
    if check_snapshot_announcement(project_name):
        probability += 15
        signals.append("已宣布快照时间")
        estimated_timeline = "1-2周内"
    
    # 2. Tokenomics文档发布
    if check_tokenomics_published(project_name):
        probability += 15
        signals.append("代币经济学已公开")
    
    # 3. 积分系统运行中
    if check_points_system(project_name):
        probability += 12
        signals.append("积分系统运行中")
        if not estimated_timeline:
            estimated_timeline = "1-3个月内"
    
    # 4. 完成审计
    if check_audit_completed(project_name):
        probability += 10
        signals.append("智能合约审计完成")
    
    # 中等信号（每个+8%概率）
    
    # 5. 主网已上线
    if check_mainnet_status(project_name):
        probability += 8
        signals.append("主网已上线")
        if not estimated_timeline:
            estimated_timeline = "3-6个月内"
    
    # 6. 完成大额融资
    funding = check_funding_info(project_name)
    if funding and funding["amount"] > 20_000_000:  # >$20M
        probability += 8
        signals.append(f"完成${funding['amount']/1e6:.0f}M融资")
    
    # 7. 招聘Tokenomics相关职位
    if check_tokenomics_hiring(project_name):
        probability += 6
        signals.append("正在招聘代币经济学设计师")
    
    # 弱信号（每个+5%概率）
    
    # 8. 竞品刚发币
    competitors = find_competitors(project_name)
    recent_launches = [c for c in competitors if c["token_launch_date"] > datetime.now() - timedelta(days=90)]
    if recent_launches:
        probability += 5
        signals.append("竞品最近发币，可能跟进")
    
    # 9. 路线图提及代币
    roadmap = get_roadmap(project_name)
    if roadmap and "token" in roadmap.lower():
        probability += 5
        signals.append("路线图提及代币")
    
    # 10. 官方社交媒体高频提及"soon"
    recent_posts = get_recent_social_posts(project_name, days=30)
    soon_count = sum([1 for post in recent_posts if "soon" in post.lower()])
    if soon_count > 5:
        probability += 5
        signals.append("官方频繁暗示'即将推出'")
    
    # 负面信号（降低概率）
    
    # 团队明确表示短期不发币
    if check_no_token_statement(project_name):
        probability *= 0.5
        signals.append("⚠️ 团队表示短期不考虑发币")
    
    probability = min(100, probability)
    
    # 确定置信区间
    if probability >= 80:
        confidence = "Very High"
        timeline = estimated_timeline or "1-2个月内"
    elif probability >= 60:
        confidence = "High"
        timeline = estimated_timeline or "2-4个月内"
    elif probability >= 40:
        confidence = "Medium"
        timeline = estimated_timeline or "4-6个月内"
    elif probability >= 20:
        confidence = "Low"
        timeline = estimated_timeline or "6-12个月内"
    else:
        confidence = "Very Low"
        timeline = "未知或12个月以上"
    
    return {
        "project_name": project_name,
        "launch_probability": probability,
        "confidence": confidence,
        "estimated_timeline": timeline,
        "detected_signals": signals,
        "signal_count": len(signals)
    }
```

### 3.6 空投价值估算

```python
def estimate_airdrop_value(project_name: str) -> dict:
    """估算空投价值"""
    
    # 1. 找到相似的历史项目
    similar_projects = find_similar_historical_projects(project_name)
    
    if not similar_projects:
        return {
            "estimated_value_usd": 0,
            "confidence": "Low",
            "method": "No similar cases"
        }
    
    # 2. 基于历史案例计算
    historical_values = []
    
    for project in similar_projects:
        # 获取该项目的空投数据
        airdrop_data = get_historical_airdrop(project["name"])
        
        if airdrop_data:
            # 调整系数（基于项目规模差异）
            adjustment = calculate_scale_adjustment(project_name, project["name"])
            
            adjusted_value = airdrop_data["avg_value_per_user"] * adjustment
            historical_values.append(adjusted_value)
    
    # 3. 取中位数作为估值
    if historical_values:
        estimated_value = sorted(historical_values)[len(historical_values) // 2]
    else:
        estimated_value = 0
    
    # 4. 计算置信度
    confidence = "High" if len(historical_values) >= 3 else "Medium" if len(historical_values) >= 2 else "Low"
    
    return {
        "project_name": project_name,
        "estimated_value_usd": int(estimated_value),
        "value_range_usd": {
            "min": int(min(historical_values)) if historical_values else 0,
            "max": int(max(historical_values)) if historical_values else 0
        },
        "confidence": confidence,
        "reference_cases": [p["name"] for p in similar_projects],
        "calculation_method": "Historical Comparison"
    }


def find_similar_historical_projects(project_name: str) -> List[dict]:
    """找到相似的历史项目"""
    
    # 获取目标项目特征
    target_features = extract_project_features(project_name)
    
    # 历史成功案例库
    historical_cases = load_historical_airdrop_cases()
    
    # 计算相似度
    similarities = []
    
    for case in historical_cases:
        case_features = extract_project_features(case["name"])
        similarity = calculate_feature_similarity(target_features, case_features)
        
        similarities.append({
            "name": case["name"],
            "similarity": similarity,
            "airdrop_data": case["airdrop"]
        })
    
    # 返回最相似的3个
    similarities.sort(key=lambda x: x["similarity"], reverse=True)
    return similarities[:3]


def extract_project_features(project_name: str) -> dict:
    """提取项目特征"""
    
    return {
        "category": get_project_category(project_name),  # DeFi, NFT, GameFi等
        "tvl": get_tvl(project_name) or 0,
        "user_count": get_user_count(project_name) or 0,
        "funding_amount": get_funding_amount(project_name) or 0,
        "community_size": get_community_size(project_name) or 0,
        "age_days": get_project_age(project_name) or 0,
    }


def calculate_feature_similarity(features1: dict, features2: dict) -> float:
    """计算特征相似度（0-1）"""
    
    similarity = 0
    
    # 类别相同（权重30%）
    if features1["category"] == features2["category"]:
        similarity += 0.3
    
    # TVL相似度（权重25%）
    if features1["tvl"] > 0 and features2["tvl"] > 0:
        tvl_ratio = min(features1["tvl"], features2["tvl"]) / max(features1["tvl"], features2["tvl"])
        similarity += 0.25 * tvl_ratio
    
    # 用户数相似度（权重20%）
    if features1["user_count"] > 0 and features2["user_count"] > 0:
        user_ratio = min(features1["user_count"], features2["user_count"]) / max(features1["user_count"], features2["user_count"])
        similarity += 0.20 * user_ratio
    
    # 融资额相似度（权重15%）
    if features1["funding_amount"] > 0 and features2["funding_amount"] > 0:
        funding_ratio = min(features1["funding_amount"], features2["funding_amount"]) / max(features1["funding_amount"], features2["funding_amount"])
        similarity += 0.15 * funding_ratio
    
    # 社区规模相似度（权重10%）
    if features1["community_size"] > 0 and features2["community_size"] > 0:
        community_ratio = min(features1["community_size"], features2["community_size"]) / max(features1["community_size"], features2["community_size"])
        similarity += 0.10 * community_ratio
    
    return similarity
```

---

## 📈 第四步: 分级与推送策略

### 4.1 项目分级标准

```python
def classify_project(score: ProjectScore, launch_prob: dict, airdrop_value: dict) -> dict:
    """项目分级"""
    
    # 综合评分
    composite = score.composite_score
    
    # 发币概率
    probability = launch_prob["launch_probability"]
    
    # 空投价值
    value = airdrop_value["estimated_value_usd"]
    
    # 分级逻辑
    if composite >= 85 and probability >= 80:
        tier = "S"
        priority = "Critical"
        action = "立即推送 + 立即参与"
        
    elif composite >= 70 and probability >= 60:
        tier = "A"
        priority = "High"
        action = "每日报告 + 优先参与"
        
    elif composite >= 55 and probability >= 40:
        tier = "B"
        priority = "Medium"
        action = "每日报告 + 观察"
        
    else:
        tier = "C"
        priority = "Low"
        action = "仅记录，不推送"
    
    # 特殊提升：空投价值特别高
    if value > 5000 and tier in ["B", "C"]:
        tier = "A"
        priority = "High"
        action = "高价值空投，升级推送"
    
    return {
        "tier": tier,
        "priority": priority,
        "recommended_action": action,
        "rationale": generate_rationale(score, launch_prob, airdrop_value)
    }
```

---

## 📊 验收标准

### 功能验收

- ✅ 能够从多平台发现新项目（日发现 > 50个）
- ✅ 能够计算项目话题热度
- ✅ 能够从评论区提取项目提及
- ✅ 能够交叉验证项目真实性
- ✅ 能够识别诈骗项目（准确率 > 85%）
- ✅ 能够过滤已发币项目
- ✅ 能够进行六维度评分
- ✅ 能够预测发币概率
- ✅ 能够估算空投价值
- ✅ 能够进行项目分级

### 性能验收

- ✅ 单项目完整评估时间 < 5分钟
- ✅ 批量评估（50个项目）时间 < 1小时
- ✅ S级项目发现后推送延迟 < 10分钟

### 质量验收

- ✅ 项目发现准确率 > 80%（真实项目 vs 噪音）
- ✅ 评分与实际表现相关性 > 0.7
- ✅ 发币概率预测准确率 > 70%
- ✅ 空投价值估算误差 < 50%
- ✅ S级项目中，3个月内发币率 > 80%

---

**文档版本**: v1.0  
**最后更新**: 2025-10-04  
**负责人**: 产品经理

