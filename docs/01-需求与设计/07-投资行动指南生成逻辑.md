# 投资行动指南生成逻辑

## 📋 文档概述

**文档目标**: 设计从项目评分到具体投资行动的完整执行方案  
**核心理念**: 预算分配 + 风险控制 + 自动化执行  
**月预算**: ¥20,000（激进策略）  
**更新时间**: 2025-10-04

---

## 🎯 投资策略定位

### 风险偏好：激进型

**特征**:
- 目标收益: 10-100倍
- 风险承受: 可接受单项目全损
- 投资阶段: 种子期/测试网阶段
- 持仓周期: 1-6个月
- 分散度: 5-10个项目

**与其他策略对比**:

| 策略类型 | 月预算 | 项目数 | 单项目投入 | 目标收益 | 风险等级 |
|---------|--------|--------|-----------|---------|---------|
| 保守型 | ¥20K | 10-15 | ¥1-2K | 2-5倍 | ⭐ |
| 稳健型 | ¥20K | 8-12 | ¥1.5-3K | 3-10倍 | ⭐⭐ |
| **激进型** | **¥20K** | **5-10** | **¥2-5K** | **10-100倍** | **⭐⭐⭐** |
| 极端型 | ¥20K | 3-5 | ¥4-7K | 50-1000倍 | ⭐⭐⭐⭐⭐ |

---

## 💰 预算分配策略

### 2.1 总体预算分配

```python
MONTHLY_BUDGET = 20000  # 人民币

BUDGET_ALLOCATION = {
    # 按优先级分配
    "S级项目": {
        "预算": 8000,  # 40%
        "项目数": "2-3个",
        "单项目预算": "2500-4000",
        "说明": "最高优先级，立即参与"
    },
    
    "A级项目": {
        "预算": 8000,  # 40%
        "项目数": "3-4个",
        "单项目预算": "2000-2500",
        "说明": "高潜力，积极参与"
    },
    
    "B级项目": {
        "预算": 2000,  # 10%
        "项目数": "2-3个",
        "单项目预算": "500-1000",
        "说明": "观察仓位，小额试水"
    },
    
    "应急储备": {
        "预算": 2000,  # 10%
        "说明": "应对突发S级机会"
    }
}
```

### 2.2 动态预算调整

```python
def adjust_budget_allocation(current_month: int, performance: dict) -> dict:
    """根据表现动态调整预算"""
    
    base_budget = 20000
    
    # 如果上月表现好，增加预算
    if performance["total_roi"] > 2.0:  # 翻倍
        adjusted_budget = base_budget * 1.2  # 增加20%
    elif performance["total_roi"] > 1.5:
        adjusted_budget = base_budget * 1.1  # 增加10%
    elif performance["total_roi"] < 0.5:  # 亏损50%
        adjusted_budget = base_budget * 0.8  # 减少20%
    else:
        adjusted_budget = base_budget
    
    # 根据市场情况调整
    market_sentiment = get_market_sentiment()
    
    if market_sentiment == "Extreme Greed":
        # 市场过热，减少投入
        adjusted_budget *= 0.8
    elif market_sentiment == "Extreme Fear":
        # 市场恐慌，增加投入（抄底）
        adjusted_budget *= 1.2
    
    return {
        "month": current_month,
        "base_budget": base_budget,
        "adjusted_budget": int(adjusted_budget),
        "adjustment_reason": generate_reason(performance, market_sentiment)
    }
```

### 2.3 单项目预算计算

```python
def calculate_project_budget(
    project: dict,
    tier: str,
    score: int,
    launch_probability: float,
    airdrop_value: int,
    available_budget: float
) -> int:
    """计算单个项目的投入预算"""
    
    # 基础预算（根据分级）
    base_budget_map = {
        "S": 3500,
        "A": 2200,
        "B": 800,
        "C": 0
    }
    
    base = base_budget_map.get(tier, 0)
    
    # 调整因子
    
    # 1. 评分调整（±20%）
    score_factor = 1.0 + (score - 75) * 0.004  # 评分每高1分，多投0.4%
    
    # 2. 发币概率调整（±30%）
    prob_factor = 0.7 + launch_probability * 0.006  # 概率每高1%，多投0.6%
    
    # 3. 空投价值调整（±25%）
    if airdrop_value > 5000:
        value_factor = 1.25
    elif airdrop_value > 3000:
        value_factor = 1.15
    elif airdrop_value > 1000:
        value_factor = 1.0
    else:
        value_factor = 0.85
    
    # 4. 时机紧迫性调整（±15%）
    urgency = assess_urgency(project)
    if urgency == "Critical":
        urgency_factor = 1.15
    elif urgency == "High":
        urgency_factor = 1.05
    else:
        urgency_factor = 1.0
    
    # 综合计算
    calculated_budget = base * score_factor * prob_factor * value_factor * urgency_factor
    
    # 限制范围
    max_budget = available_budget * 0.3  # 单项目不超过可用预算的30%
    min_budget = 500 if tier != "C" else 0
    
    final_budget = max(min_budget, min(calculated_budget, max_budget))
    
    return int(final_budget)


def assess_urgency(project: dict) -> str:
    """评估时机紧迫性"""
    
    # 检查快照时间
    if project.get("snapshot_announced"):
        days_until_snapshot = (project["snapshot_date"] - datetime.now()).days
        
        if days_until_snapshot <= 7:
            return "Critical"  # 7天内快照
        elif days_until_snapshot <= 30:
            return "High"  # 30天内快照
    
    # 检查白名单截止
    if project.get("whitelist_deadline"):
        days_until_deadline = (project["whitelist_deadline"] - datetime.now()).days
        
        if days_until_deadline <= 3:
            return "Critical"
        elif days_until_deadline <= 14:
            return "High"
    
    return "Normal"
```

---

## 📋 行动指南生成

### 3.1 行动计划结构

```python
class ActionPlan(BaseModel):
    """投资行动计划"""
    
    # 项目信息
    project_name: str
    project_tier: str  # S/A/B/C
    composite_score: int
    
    # 预算分配
    total_budget: int  # 人民币
    budget_breakdown: dict  # 详细预算分配
    
    # 时间规划
    start_date: date
    target_duration: str  # 例如: "30-90天"
    deadline: Optional[date]
    urgency: str  # Critical, High, Normal, Low
    
    # 具体步骤
    action_steps: List[ActionStep]
    
    # 监控指标
    monitoring_metrics: List[str]
    alert_conditions: List[str]
    
    # 风险控制
    risks: List[str]
    stop_loss_conditions: List[str]
    
    # 预期收益
    expected_roi: str  # 例如: "10-50倍"
    airdrop_estimate: int  # USD
    
    # 备注
    notes: List[str]


class ActionStep(BaseModel):
    """单个行动步骤"""
    
    step_number: int
    action: str
    deadline: Optional[str]
    cost_estimate: str
    status: str  # pending, in_progress, completed, skipped
    priority: str  # high, medium, low
    dependencies: List[int]  # 依赖的步骤编号
    notes: Optional[str]
```

### 3.2 生成行动计划

```python
def generate_action_plan(
    project: dict,
    score: ProjectScore,
    launch_prob: dict,
    airdrop_value: dict,
    budget: int
) -> ActionPlan:
    """生成完整的投资行动计划"""
    
    # 确定项目类型
    category = project["category"]  # DeFi, L2, NFT, GameFi等
    
    # 评估紧迫性
    urgency = assess_urgency(project)
    
    # 生成行动步骤
    steps = generate_action_steps(project, category, budget, urgency)
    
    # 生成预算分配
    budget_breakdown = calculate_budget_breakdown(budget, category, steps)
    
    # 生成监控指标
    monitoring = generate_monitoring_metrics(project, category)
    
    # 生成风险提示
    risks = identify_risks(project, score, launch_prob)
    
    # 计算预期收益
    expected_roi = estimate_roi(score.composite_score, launch_prob["launch_probability"])
    
    return ActionPlan(
        project_name=project["name"],
        project_tier=classify_tier(score),
        composite_score=score.composite_score,
        total_budget=budget,
        budget_breakdown=budget_breakdown,
        start_date=date.today(),
        target_duration=launch_prob.get("estimated_timeline", "1-3个月"),
        deadline=calculate_deadline(launch_prob),
        urgency=urgency,
        action_steps=steps,
        monitoring_metrics=monitoring,
        alert_conditions=generate_alert_conditions(project),
        risks=risks,
        stop_loss_conditions=generate_stop_loss_conditions(budget),
        expected_roi=expected_roi,
        airdrop_estimate=airdrop_value["estimated_value_usd"],
        notes=generate_additional_notes(project)
    )
```

### 3.3 针对不同类型项目的行动步骤

#### DeFi协议

```python
def generate_defi_action_steps(project: dict, budget: int, urgency: str) -> List[ActionStep]:
    """生成DeFi项目行动步骤"""
    
    steps = []
    
    # Step 1: 准备钱包
    steps.append(ActionStep(
        step_number=1,
        action="创建新钱包或准备专用钱包",
        deadline="立即",
        cost_estimate="¥0",
        status="pending",
        priority="high",
        dependencies=[],
        notes="建议使用新钱包，避免关联其他活动"
    ))
    
    # Step 2: 准备资金
    steps.append(ActionStep(
        step_number=2,
        action="准备资金并桥接到目标链",
        deadline="24小时内",
        cost_estimate=f"¥{int(budget * 0.6)} + 跨链Gas费约¥{int(budget * 0.05)}",
        status="pending",
        priority="high",
        dependencies=[1],
        notes=f"主网: {project.get('blockchain', 'Ethereum')}"
    ))
    
    # Step 3: 加入社区
    steps.append(ActionStep(
        step_number=3,
        action="加入官方社区（Twitter + Telegram + Discord）",
        deadline="24小时内",
        cost_estimate="¥0",
        status="pending",
        priority="medium",
        dependencies=[],
        notes="关注官方公告，了解最新动态"
    ))
    
    # Step 4: 交互协议
    main_budget = int(budget * 0.6)
    gas_budget = int(budget * 0.15)
    
    steps.append(ActionStep(
        step_number=4,
        action=f"存入资金到协议（建议分3-5次存入，每次{main_budget//4}元左右）",
        deadline="3天内完成首次存入",
        cost_estimate=f"¥{main_budget}",
        status="pending",
        priority="high",
        dependencies=[2],
        notes="不要一次性全部存入，分批操作更像真实用户"
    ))
    
    steps.append(ActionStep(
        step_number=5,
        action=f"执行多样化交易（至少10笔不同类型的交易）",
        deadline="持续进行，覆盖整个参与周期",
        cost_estimate=f"Gas费约¥{gas_budget}",
        status="pending",
        priority="high",
        dependencies=[4],
        notes="包括：存款、取款、Swap、添加流动性等"
    ))
    
    # Step 6: 保持活跃
    steps.append(ActionStep(
        step_number=6,
        action="保持协议活跃度（每周至少2-3笔交易）",
        deadline="持续至快照",
        cost_estimate="Gas费计入Step 5",
        status="pending",
        priority="medium",
        dependencies=[5],
        notes="活跃用户通常获得更多空投"
    ))
    
    # Step 7: 参与治理（如果有）
    if project.get("has_governance"):
        steps.append(ActionStep(
            step_number=7,
            action="参与治理投票（如有提案）",
            deadline="有提案时立即参与",
            cost_estimate="Gas费约¥50",
            status="pending",
            priority="low",
            dependencies=[4],
            notes="治理参与者可能获得额外空投权重"
        ))
    
    # Step 8: 邀请好友（如果有推荐系统）
    if project.get("has_referral"):
        steps.append(ActionStep(
            step_number=8,
            action="邀请3-5个好友（真实用户或小号）",
            deadline="快照前2周",
            cost_estimate="¥0（使用已有联系人）",
            status="pending",
            priority="low",
            dependencies=[4],
            notes="有些项目会给推荐人额外奖励"
        ))
    
    return steps
```

#### Layer2 / 新公链

```python
def generate_l2_action_steps(project: dict, budget: int, urgency: str) -> List[ActionStep]:
    """生成L2/新公链项目行动步骤"""
    
    steps = []
    
    # Step 1-3: 同DeFi
    steps.extend(generate_defi_action_steps(project, budget, urgency)[:3])
    
    # Step 4: 桥接资产到L2
    bridge_amount = int(budget * 0.5)
    
    steps.append(ActionStep(
        step_number=4,
        action=f"使用官方桥接资产到{project['name']}",
        deadline="3天内",
        cost_estimate=f"¥{bridge_amount} + 桥接费约¥{int(budget * 0.05)}",
        status="pending",
        priority="high",
        dependencies=[2],
        notes=f"官方桥: {project.get('official_bridge', '见项目文档')}"
    ))
    
    # Step 5: 在L2上使用多个Dapp
    steps.append(ActionStep(
        step_number=5,
        action="在L2上使用至少5个不同的Dapp",
        deadline="2周内完成首轮交互",
        cost_estimate=f"Gas费约¥{int(budget * 0.1)}（L2 Gas费很低）",
        status="pending",
        priority="high",
        dependencies=[4],
        notes="包括：DEX、借贷、NFT市场、游戏等"
    ))
    
    # Step 6: 多样化活动
    steps.append(ActionStep(
        step_number=6,
        action="执行多样化交易（目标：每个Dapp至少3笔交易）",
        deadline="持续进行",
        cost_estimate="Gas费计入Step 5",
        status="pending",
        priority="high",
        dependencies=[5],
        notes="交易类型越多样，空投概率越大"
    ))
    
    # Step 7: 保持活跃周期
    steps.append(ActionStep(
        step_number=7,
        action="保持活跃（每周至少在3个不同Dapp上操作）",
        deadline="持续至快照",
        cost_estimate="Gas费约¥{int(budget * 0.05)}/周",
        status="pending",
        priority="medium",
        dependencies=[6],
        notes="活跃天数和活跃周数是常见的空投标准"
    ))
    
    # Step 8: 跨链桥往返
    if project.get("supports_bridges"):
        steps.append(ActionStep(
            step_number=8,
            action="使用不同桥接方案往返（至少2次）",
            deadline="快照前1个月",
            cost_estimate="桥接费约¥{int(budget * 0.1)}",
            status="pending",
            priority="low",
            dependencies=[4],
            notes="使用多个桥可能增加权重"
        ))
    
    return steps
```

#### NFT项目

```python
def generate_nft_action_steps(project: dict, budget: int, urgency: str) -> List[ActionStep]:
    """生成NFT项目行动步骤"""
    
    steps = []
    
    # NFT项目通常有白名单机制
    
    # Step 1: 加入Discord（必须）
    steps.append(ActionStep(
        step_number=1,
        action="加入项目Discord并完成身份验证",
        deadline="立即",
        cost_estimate="¥0",
        status="pending",
        priority="high",
        dependencies=[],
        notes="Discord是NFT项目的核心社区"
    ))
    
    # Step 2: 获取身份角色
    steps.append(ActionStep(
        step_number=2,
        action="获取社区身份角色（通过互动、邀请等）",
        deadline="1周内",
        cost_estimate="¥0（时间成本）",
        status="pending",
        priority="high",
        dependencies=[1],
        notes="有些角色是白名单的前提条件"
    ))
    
    # Step 3: 参与社区活动
    steps.append(ActionStep(
        step_number=3,
        action="积极参与社区活动（每周至少5条有意义的发言）",
        deadline="持续进行",
        cost_estimate="¥0（时间成本）",
        status="pending",
        priority="high",
        dependencies=[2],
        notes="活跃度是白名单筛选的重要指标"
    ))
    
    # Step 4: 完成任务
    if project.get("has_tasks"):
        steps.append(ActionStep(
            step_number=4,
            action="完成Crew3/Zealy/Galxe等平台任务",
            deadline="任务截止前",
            cost_estimate="¥0-200（可能需要Gas费）",
            status="pending",
            priority="high",
            dependencies=[1],
            notes="查看项目公告了解具体任务平台"
        ))
    
    # Step 5: 申请白名单
    mint_budget = int(budget * 0.7)
    
    steps.append(ActionStep(
        step_number=5,
        action="白名单开放时立即申请",
        deadline="白名单开放时",
        cost_estimate="¥0",
        status="pending",
        priority="critical",
        dependencies=[2, 3],
        notes="设置提醒，避免错过"
    ))
    
    # Step 6: Mint NFT
    steps.append(ActionStep(
        step_number=6,
        action=f"Mint NFT（预算¥{mint_budget}，建议Mint 2-3个）",
        deadline="Mint开启后2小时内",
        cost_estimate=f"¥{mint_budget} + Gas费约¥{int(budget * 0.1)}",
        status="pending",
        priority="critical",
        dependencies=[5],
        notes="设置好Gas，确保交易成功"
    ))
    
    # Step 7: 持有策略
    steps.append(ActionStep(
        step_number=7,
        action="持有NFT（建议至少持有到项目发币后）",
        deadline="发币后1-3个月",
        cost_estimate="¥0（机会成本）",
        status="pending",
        priority="medium",
        dependencies=[6],
        notes="长期持有者通常有额外奖励"
    ))
    
    return steps
```

### 3.4 预算分配明细

```python
def calculate_budget_breakdown(budget: int, category: str, steps: List[ActionStep]) -> dict:
    """计算详细预算分配"""
    
    if category == "DeFi":
        return {
            "协议存款": {
                "金额": int(budget * 0.60),
                "说明": "存入协议赚取收益 + 获取空投资格"
            },
            "交易Gas费": {
                "金额": int(budget * 0.15),
                "说明": "执行各类交易的手续费"
            },
            "跨链桥接费": {
                "金额": int(budget * 0.05),
                "说明": "资金桥接到目标链"
            },
            "应急储备": {
                "金额": int(budget * 0.20),
                "说明": "应对Gas费波动、额外机会等"
            }
        }
    
    elif category in ["L2", "Layer2", "Rollup"]:
        return {
            "桥接资产": {
                "金额": int(budget * 0.50),
                "说明": "桥接到L2的主要资金"
            },
            "Dapp交互": {
                "金额": int(budget * 0.20),
                "说明": "在各个Dapp上的操作资金"
            },
            "Gas费（L1+L2）": {
                "金额": int(budget * 0.10),
                "说明": "包括跨链和L2上的Gas费"
            },
            "应急储备": {
                "金额": int(budget * 0.20),
                "说明": "灵活应对"
            }
        }
    
    elif category == "NFT":
        return {
            "NFT Mint费用": {
                "金额": int(budget * 0.70),
                "说明": "铸造NFT的主要费用"
            },
            "Gas费": {
                "金额": int(budget * 0.15),
                "说明": "Mint时的Gas费（高峰期可能很贵）"
            },
            "任务完成费用": {
                "金额": int(budget * 0.05),
                "说明": "完成链上任务可能需要的小额费用"
            },
            "应急储备": {
                "金额": int(budget * 0.10),
                "说明": "应对意外情况"
            }
        }
    
    else:  # 通用分配
        return {
            "主要参与资金": {
                "金额": int(budget * 0.70),
                "说明": "参与项目的主要资金"
            },
            "Gas和手续费": {
                "金额": int(budget * 0.15),
                "说明": "各类手续费"
            },
            "应急储备": {
                "金额": int(budget * 0.15),
                "说明": "灵活应对"
            }
        }
```

---

## 📊 监控与预警

### 4.1 监控指标

```python
def generate_monitoring_metrics(project: dict, category: str) -> List[str]:
    """生成监控指标列表"""
    
    common_metrics = [
        "官方Twitter发布快照时间公告",
        "官方Telegram/Discord发布重要更新",
        "代币经济学文档发布",
        "审计报告发布",
        "主网上线日期变更",
        "融资消息",
        "竞品项目发币动态"
    ]
    
    category_specific = {
        "DeFi": [
            "协议TVL变化（> ±20%需关注）",
            "智能合约升级",
            "流动性挖矿参数变化",
            "合约被攻击风险"
        ],
        "L2": [
            "L2每日活跃地址数",
            "L2 TVL变化",
            "新Dapp上线",
            "Gas费异常波动"
        ],
        "NFT": [
            "Mint日期公告",
            "白名单抽选结果",
            "地板价变化",
            "Holder数量变化"
        ]
    }
    
    return common_metrics + category_specific.get(category, [])
```

### 4.2 预警条件

```python
def generate_alert_conditions(project: dict) -> List[str]:
    """生成预警条件"""
    
    return [
        "🚨 快照时间公告（Critical - 立即查看钱包活动记录）",
        "🚨 白名单开放（Critical - 立即申请）",
        "🚨 Mint开始（Critical - 立即执行）",
        "⚠️ 代币经济学发布（High - 评估是否继续参与）",
        "⚠️ 审计报告有严重漏洞（High - 考虑退出）",
        "⚠️ 官方声明延期发币（Medium - 重新评估）",
        "⚠️ 社区负面情绪激增（Medium - 调查原因）",
        "⚠️ 团队成员离职（Medium - 评估影响）",
        "ℹ️ 竞品项目发币（Low - 观察市场反应）",
        "ℹ️ 项目发布新合作伙伴（Low - 积极信号）"
    ]
```

---

## ⚠️ 风险控制

### 5.1 风险识别

```python
def identify_risks(project: dict, score: ProjectScore, launch_prob: dict) -> List[str]:
    """识别投资风险"""
    
    risks = []
    
    # 基于评分的风险
    if score.team_score < 50:
        risks.append(f"⚠️ 团队背景评分较低（{score.team_score}/100），团队能力存疑")
    
    if score.tech_score < 50:
        risks.append(f"⚠️ 技术创新评分较低（{score.tech_score}/100），技术壁垒不足")
    
    if score.risk_score < 50:
        risks.append(f"🚨 风险评分较低（{score.risk_score}/100），存在较高风险")
    
    # 基于发币概率的风险
    if launch_prob["launch_probability"] < 40:
        risks.append(f"⚠️ 发币概率较低（{launch_prob['launch_probability']}%），可能长期不发币")
    
    # 基于项目特征的风险
    if not project.get("has_audit"):
        risks.append("⚠️ 智能合约未经审计，存在安全风险")
    
    if project.get("team_anonymous", True):
        risks.append("⚠️ 团队匿名，存在跑路风险")
    
    if project.get("token_concentration", 0) > 0.5:
        risks.append(f"⚠️ 代币集中度过高（{project['token_concentration']*100:.0f}%），存在砸盘风险")
    
    # 市场风险
    competitors = project.get("competitor_count", 0)
    if competitors > 5:
        risks.append(f"⚠️ 同类竞品较多（{competitors}个），市场竞争激烈")
    
    # 时间风险
    if launch_prob.get("estimated_timeline") == "未知或12个月以上":
        risks.append("⚠️ 发币时间不明确，资金可能长期锁定")
    
    # 合规风险
    if project.get("regulatory_concerns"):
        risks.append("⚠️ 存在合规问题，可能面临监管风险")
    
    return risks
```

### 5.2 止损条件

```python
def generate_stop_loss_conditions(budget: int) -> List[str]:
    """生成止损条件"""
    
    return [
        f"💸 资金损失 > {int(budget * 0.5)}元（50%）- 立即退出",
        f"💸 资金损失 > {int(budget * 0.3)}元（30%）- 评估是否退出",
        "🚨 智能合约被攻击 - 立即提现所有资金",
        "🚨 项目方跑路迹象（删除社交媒体、团队消失）- 立即退出",
        "🚨 官方宣布项目终止 - 立即退出",
        "⚠️ 连续3个月无任何进展 - 考虑退出",
        "⚠️ 社区成员大量流失（> 50%）- 重新评估",
        "⚠️ TVL/活跃用户暴跌（> 70%）- 考虑退出",
        "⚠️ 竞品项目发币后表现极差 - 降低预期",
        "ℹ️ 官方表示短期不发币 - 调整策略或退出"
    ]
```

### 5.3 风险等级评估

```python
def assess_overall_risk(project: dict, score: ProjectScore, risks: List[str]) -> dict:
    """评估整体风险等级"""
    
    risk_points = 0
    
    # 基于评分
    if score.composite_score < 60:
        risk_points += 30
    elif score.composite_score < 70:
        risk_points += 20
    elif score.composite_score < 80:
        risk_points += 10
    
    # 基于风险数量
    critical_risks = len([r for r in risks if r.startswith("🚨")])
    high_risks = len([r for r in risks if r.startswith("⚠️")])
    
    risk_points += critical_risks * 15
    risk_points += high_risks * 8
    
    # 基于特定风险
    if "团队匿名" in str(risks):
        risk_points += 20
    
    if "未经审计" in str(risks):
        risk_points += 15
    
    # 确定风险等级
    if risk_points >= 60:
        risk_level = "Very High"
        recommendation = "不建议参与"
    elif risk_points >= 40:
        risk_level = "High"
        recommendation = "谨慎参与，仅小仓位"
    elif risk_points >= 20:
        risk_level = "Medium"
        recommendation = "可以参与，注意风险"
    else:
        risk_level = "Low"
        recommendation = "风险可控，建议参与"
    
    return {
        "risk_level": risk_level,
        "risk_score": risk_points,
        "recommendation": recommendation,
        "should_participate": risk_points < 60
    }
```

---

## 🤖 自动化执行（可选）

### 6.1 自动执行框架

```python
class AutomatedExecutor:
    """自动化执行器"""
    
    def __init__(self, wallet_address: str, monthly_budget: int = 20000):
        self.wallet = wallet_address
        self.budget = monthly_budget
        self.used_budget = 0
        self.active_projects = []
    
    async def execute_action_plan(self, plan: ActionPlan, auto_mode: bool = False):
        """执行行动计划"""
        
        logger.info(f"开始执行项目: {plan.project_name}")
        
        for step in plan.action_steps:
            # 检查是否满足依赖
            if not self.check_dependencies(step, plan):
                logger.warning(f"步骤 {step.step_number} 依赖未满足，跳过")
                continue
            
            # 执行步骤
            if auto_mode and step.priority in ["critical", "high"]:
                # 自动执行
                success = await self.auto_execute_step(step, plan)
            else:
                # 手动确认
                success = await self.manual_confirm_step(step, plan)
            
            # 更新状态
            if success:
                step.status = "completed"
                logger.info(f"✅ 步骤 {step.step_number} 完成: {step.action}")
            else:
                step.status = "failed"
                logger.error(f"❌ 步骤 {step.step_number} 失败: {step.action}")
                
                # 关键步骤失败，中止计划
                if step.priority == "critical":
                    logger.error(f"关键步骤失败，中止执行")
                    break
        
        # 添加到监控列表
        self.active_projects.append({
            "project": plan.project_name,
            "plan": plan,
            "started_at": datetime.now(),
            "budget_used": plan.total_budget
        })
        
        self.used_budget += plan.total_budget
    
    async def auto_execute_step(self, step: ActionStep, plan: ActionPlan) -> bool:
        """自动执行步骤（需用户授权）"""
        
        try:
            # 根据步骤类型执行
            if "桥接" in step.action:
                return await self.execute_bridge(step, plan)
            
            elif "存入" in step.action or "deposit" in step.action.lower():
                return await self.execute_deposit(step, plan)
            
            elif "交易" in step.action or "swap" in step.action.lower():
                return await self.execute_swap(step, plan)
            
            elif "Mint" in step.action or "铸造" in step.action:
                return await self.execute_mint(step, plan)
            
            else:
                # 不支持自动执行的步骤
                logger.info(f"步骤需要手动执行: {step.action}")
                return await self.manual_confirm_step(step, plan)
        
        except Exception as e:
            logger.error(f"自动执行失败: {e}")
            return False
    
    async def execute_bridge(self, step: ActionStep, plan: ActionPlan) -> bool:
        """执行跨链桥接"""
        
        # 提取金额
        amount = extract_amount(step.cost_estimate)
        
        # 调用跨链桥接合约
        tx = await bridge_assets(
            from_chain=project["source_chain"],
            to_chain=project["target_chain"],
            amount=amount,
            wallet=self.wallet
        )
        
        if tx["status"] == "success":
            logger.info(f"✅ 桥接成功: {tx['hash']}")
            return True
        else:
            logger.error(f"❌ 桥接失败: {tx['error']}")
            return False
    
    async def monitor_active_projects(self):
        """监控活跃项目"""
        
        for project_data in self.active_projects:
            project = project_data["project"]
            plan = project_data["plan"]
            
            # 检查是否有重要更新
            updates = await check_project_updates(project)
            
            # 快照公告
            if updates.get("snapshot_announced"):
                await self.send_urgent_alert(
                    f"🚨 {project} 宣布快照！",
                    f"快照时间: {updates['snapshot_date']}",
                    "请检查你的钱包活动"
                )
            
            # 发币公告
            if updates.get("token_launched"):
                await self.send_alert(
                    f"🎉 {project} 代币已上线！",
                    f"代币地址: {updates['token_address']}",
                    "请查看空投资格"
                )
                
                # 计算ROI
                roi = await self.calculate_project_roi(project_data)
                await self.generate_performance_report(project, roi)
            
            # 风险预警
            if updates.get("risk_alert"):
                await self.send_alert(
                    f"⚠️ {project} 风险警告！",
                    updates["risk_description"],
                    "请评估是否需要退出"
                )
```

---

## 📊 ROI计算与绩效评估

```python
def calculate_expected_roi(
    composite_score: int,
    launch_probability: float,
    airdrop_value: int,
    budget: int
) -> dict:
    """计算预期ROI"""
    
    # 基础ROI（基于历史数据）
    if composite_score >= 85:
        base_roi = 30  # 30倍
    elif composite_score >= 70:
        base_roi = 15  # 15倍
    elif composite_score >= 60:
        base_roi = 8   # 8倍
    else:
        base_roi = 3   # 3倍
    
    # 概率调整
    probability_adjusted_roi = base_roi * (launch_probability / 100)
    
    # 价值调整
    if airdrop_value > 0:
        value_based_roi = (airdrop_value * 6.5) / budget  # USD转CNY（汇率约6.5）
        
        # 取两者的加权平均
        final_roi = probability_adjusted_roi * 0.6 + value_based_roi * 0.4
    else:
        final_roi = probability_adjusted_roi
    
    return {
        "expected_roi_multiple": round(final_roi, 1),
        "expected_roi_percentage": f"{(final_roi - 1) * 100:.0f}%",
        "expected_profit_cny": int(budget * (final_roi - 1)),
        "risk_adjusted_roi": round(final_roi * (composite_score / 100), 1),
        "confidence_level": "High" if composite_score >= 80 else "Medium"
    }


def generate_performance_report(project_name: str, actual_roi: float, plan: ActionPlan) -> dict:
    """生成绩效报告"""
    
    expected_roi = plan.expected_roi
    
    return {
        "project_name": project_name,
        "investment_date": plan.start_date,
        "exit_date": date.today(),
        "duration_days": (date.today() - plan.start_date).days,
        
        "budget": {
            "planned": plan.total_budget,
            "actual_used": calculate_actual_used(project_name)
        },
        
        "roi": {
            "expected": expected_roi,
            "actual": actual_roi,
            "performance": "超预期" if actual_roi > expected_roi else "符合预期" if actual_roi >= expected_roi * 0.8 else "低于预期"
        },
        
        "profit": {
            "absolute_cny": int(plan.total_budget * (actual_roi - 1)),
            "percentage": f"{(actual_roi - 1) * 100:.0f}%"
        },
        
        "lessons_learned": generate_lessons(project_name, actual_roi, expected_roi)
    }
```

---

## 📋 验收标准

### 功能验收

- ✅ 能够根据项目评分生成完整的行动计划
- ✅ 能够根据项目类型定制行动步骤
- ✅ 能够计算详细的预算分配
- ✅ 能够生成监控指标和预警条件
- ✅ 能够识别风险并生成止损条件
- ✅ 能够计算预期ROI
- ✅ 能够生成绩效报告

### 性能验收

- ✅ 单项目行动计划生成时间 < 30秒
- ✅ 支持同时监控 10+ 活跃项目
- ✅ 预警响应时间 < 5分钟

### 质量验收

- ✅ 行动步骤完整性 > 95%（包含所有必要步骤）
- ✅ 预算分配合理性（测试用户评分 > 4/5）
- ✅ ROI预测准确率 > 60%（实际ROI在预测范围内）
- ✅ 风险识别召回率 > 85%（识别出的风险 / 实际风险）

---

**文档版本**: v1.0  
**最后更新**: 2025-10-04  
**负责人**: 产品经理

